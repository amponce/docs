---
title: "Web Calls"
sidebarTitle: "Web Calls"
description: "Browser-based voice calls via WebSocket using the Web Audio API."
---

## Overview

Web calls let users talk to your AI agent directly from a browser or web application. No phone number is needed -- audio streams over a WebSocket connection using 16-bit PCM at 16kHz mono.

## How It Works

```
1. Your server creates a web call via POST /v1/calls/web
2. API returns a callId, accessToken, and websocketUrl
3. Your frontend connects to the WebSocket URL
4. Browser streams microphone audio -> Relay Agent
5. Relay Agent streams TTS audio -> browser
```

## Step 1: Create a Web Call

Your backend creates the call and receives a one-time access token.

<CodeGroup>

```bash cURL
curl -X POST https://your-host/v1/calls/web \
  -H "Authorization: Bearer ra_your_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "agentId": "agent_abc123def456",
    "dynamicVariables": {
      "userName": "Alex"
    },
    "metadata": {
      "source": "support-widget"
    }
  }'
```

```typescript TypeScript
const response = await fetch("https://your-host/v1/calls/web", {
  method: "POST",
  headers: {
    "Authorization": "Bearer ra_your_api_key",
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    agentId: "agent_abc123def456",
    dynamicVariables: { userName: "Alex" },
    metadata: { source: "support-widget" },
  }),
});

const call = await response.json();
// {
//   id: "call_xYz...",
//   accessToken: "rat_tok_aBcDeFg...",
//   websocketUrl: "/v1/calls/web-stream?callId=call_xYz...&agentId=agent_abc...&token=rat_tok_aBcDeFg..."
// }
```

```python Python
import requests

response = requests.post(
    "https://your-host/v1/calls/web",
    headers={
        "Authorization": "Bearer ra_your_api_key",
        "Content-Type": "application/json",
    },
    json={
        "agentId": "agent_abc123def456",
        "dynamicVariables": {"userName": "Alex"},
        "metadata": {"source": "support-widget"},
    },
)

call = response.json()
print(call["accessToken"])   # "rat_tok_aBcDeFg..."
print(call["websocketUrl"])  # "/v1/calls/web-stream?callId=..."
```

</CodeGroup>

### Request Body

| Field | Type | Required | Description |
|---|---|---|---|
| `agentId` | `string` | Yes | The agent to handle this call. |
| `composedAgentId` | `string` | No | Use a multi-agent composition. |
| `dynamicVariables` | `Record<string, string>` | No | Variables for `{{mustache}}` placeholders in the prompt. |
| `metadata` | `Record<string, unknown>` | No | Arbitrary metadata attached to the call. |
| `agentOverride` | `object` | No | Override agent settings (systemPrompt, voice, firstMessage). |

### Response

```json
{
  "id": "call_xYzAbCdEf123456789012",
  "orgId": "org_abc123",
  "agentId": "agent_abc123def456",
  "type": "web",
  "direction": "inbound",
  "status": "queued",
  "accessToken": "rat_tok_aBcDeFgHiJkLmNoPqRsTuVwXyZ",
  "websocketUrl": "/v1/calls/web-stream?callId=call_xYz...&agentId=agent_abc...&token=rat_tok_aBcDeFg..."
}
```

<Warning>
  The `accessToken` (prefixed `rat_`) is returned only once in this response. Store it securely and pass it to your frontend. It is hashed before storage -- it cannot be retrieved again.
</Warning>

## Step 2: Connect the WebSocket

Pass the `websocketUrl` to your frontend. The full URL is relative, so prepend your host with the `wss://` protocol:

```
wss://your-host/v1/calls/web-stream?callId={callId}&agentId={agentId}&token={accessToken}
```

### Authentication

The WebSocket connection is authenticated using the `token` query parameter. The server hashes the provided token and compares it against the stored hash. Invalid or missing tokens result in the connection being closed with code `4003`.

### Close Codes

| Code | Meaning |
|---|---|
| `4001` | Missing `callId` or `token` parameter. |
| `4003` | Invalid access token. |
| `4004` | Call not found. |
| `1011` | Server error (orchestrator not available). |

## Step 3: Stream Audio

### Audio Format

| Property | Value |
|---|---|
| Encoding | 16-bit signed PCM (little-endian) |
| Sample rate | 16,000 Hz |
| Channels | Mono |
| Direction | Bidirectional -- send mic audio, receive TTS audio |

The WebSocket carries raw binary frames. Send microphone audio as PCM16 buffers. Receive TTS audio as base64-encoded PCM16 in JSON messages.

## Browser Integration Example

Here is a complete example using the Web Audio API and `AudioWorklet`:

```typescript
class RelayWebCall {
  private ws: WebSocket | null = null;
  private audioContext: AudioContext | null = null;
  private mediaStream: MediaStream | null = null;
  private workletNode: AudioWorkletNode | null = null;

  async connect(websocketUrl: string) {
    // 1. Get microphone access
    this.mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: 16000,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
      },
    });

    // 2. Set up AudioContext at 16kHz
    this.audioContext = new AudioContext({ sampleRate: 16000 });

    // 3. Connect to WebSocket
    const host = window.location.host;
    this.ws = new WebSocket(`wss://${host}${websocketUrl}`);
    this.ws.binaryType = "arraybuffer";

    this.ws.onopen = () => {
      console.log("Web call connected");
      this.startCapture();
    };

    this.ws.onmessage = (event) => {
      if (typeof event.data === "string") {
        // JSON control message or base64 audio
        const msg = JSON.parse(event.data);
        if (msg.audio) {
          this.playAudio(msg.audio);
        }
      }
    };

    this.ws.onclose = (event) => {
      console.log("Web call ended:", event.code, event.reason);
      this.cleanup();
    };
  }

  private async startCapture() {
    if (!this.audioContext || !this.mediaStream) return;

    // Register the audio worklet processor
    await this.audioContext.audioWorklet.addModule("/audio-processor.js");

    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
    this.workletNode = new AudioWorkletNode(
      this.audioContext,
      "pcm-processor"
    );

    // Send PCM16 audio to WebSocket
    this.workletNode.port.onmessage = (event) => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        // event.data is a Float32Array; convert to Int16
        const float32 = event.data as Float32Array;
        const int16 = new Int16Array(float32.length);
        for (let i = 0; i < float32.length; i++) {
          const s = Math.max(-1, Math.min(1, float32[i]));
          int16[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
        }
        this.ws.send(int16.buffer);
      }
    };

    source.connect(this.workletNode);
    this.workletNode.connect(this.audioContext.destination);
  }

  private playAudio(base64Audio: string) {
    if (!this.audioContext) return;

    const binaryStr = atob(base64Audio);
    const bytes = new Uint8Array(binaryStr.length);
    for (let i = 0; i < binaryStr.length; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }

    // Convert Int16 PCM to Float32 for Web Audio API
    const int16 = new Int16Array(bytes.buffer);
    const float32 = new Float32Array(int16.length);
    for (let i = 0; i < int16.length; i++) {
      float32[i] = int16[i] / 0x8000;
    }

    const audioBuffer = this.audioContext.createBuffer(1, float32.length, 16000);
    audioBuffer.getChannelData(0).set(float32);

    const source = this.audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(this.audioContext.destination);
    source.start();
  }

  disconnect() {
    this.ws?.close();
    this.cleanup();
  }

  private cleanup() {
    this.workletNode?.disconnect();
    this.mediaStream?.getTracks().forEach((t) => t.stop());
    this.audioContext?.close();
    this.ws = null;
    this.audioContext = null;
    this.mediaStream = null;
  }
}
```

### AudioWorklet Processor (`audio-processor.js`)

```javascript
class PCMProcessor extends AudioWorkletProcessor {
  process(inputs) {
    const input = inputs[0];
    if (input.length > 0) {
      this.port.postMessage(input[0]);
    }
    return true;
  }
}

registerProcessor("pcm-processor", PCMProcessor);
```

## Rate Limits

Web call creation is rate-limited to **20 requests per minute** per API key.

<Tip>
  Web calls use raw PCM16 audio at 16kHz instead of the mulaw encoding used for phone calls. This provides higher audio quality since there is no telephony codec overhead.
</Tip>

## Next Steps

- [Outbound Phone Calls](/deploy/phone-calls) -- Call real phone numbers
- [DevTools](/monitor/devtools) -- Inspect live calls in real time
- [Latency](/monitor/latency) -- Understand and optimize audio pipeline latency
